### 0x00 分布式唯一`id`的生成策略简介

作为一个分布式唯一`id`，一般要求其具有以下特征：

* 在同一业务场景里面必须保持全局的唯一
* 趋势递增

### 0x01 数据库自增长序列或字段

最常见的方法，利用数据库，可保证全数据库唯一。

优点：

* 简单，性能可以接受；
* 代码方便，在`INSERT`语句中直接把主键字段空出来，交由数据库自动填充即可；
* 生成的数字`id`天然排序，对分页或者需要排序的结果很有帮助。

缺点：

* 不同数据库的语法和内部实现方法不同，在数据库迁移的时候可能需要额外的处理；
* 在单个数据库或者一主多从的情况下，只有一个主库可以生成，有单点故障的风险；
* 在性能达不到要求的情况下，难于扩展；
* 分表分库时可能会带来麻烦。

对于有多个主库的情况下，可以设置每个主库的起始数字不一样但步长一样。比如一个主库生成的`id`全是奇数，另外一个生成的`id`全是偶数，也可有效生成分布式唯一`id`。

### 0x02 UUID

UUID即通用唯一识别码，其设计的目的就是为了让分布式系统中的所有元素都有唯一的辨识信息，一般来说这个值生成出来就是全球唯一的。GUID是微软公司出的一套UUID生成组件。

UUID的生成即可交给数据库去做，比如可以在MySQL数据库中使用`UUID()`函数来生成UUID，MySQL中的`UUID()`函数返回的是带`-`分隔符的UUID。同时，也可以交给ORM框架去做，例如Hibernate框架就有一套自己的UUID生成机制，其返回的UUID符合如下规则：IP-JVM启动时间-当前时间右移32位-当前时间-内部计数（8-8-4-8-4）。

优点：

* 简单，很多数据库和编程语言都内置UUID的生成函数；
* 生成ID的性能好，基本不会有性能问题；
* 全球唯一，在数据迁移、数据合并或数据库变更等情况下可以从容应对。

缺点：

* 无法保证趋势递增
* 需使用字符串来存储，查询效率低
* 存储空间比较大，如果是海量数据就需要考虑存储量的问题
* 传输数据量大

### 0x03 Snowflake算法

这是Twitter公司出的分布式唯一ID的生成算法，其结果是一个64bit的整数（Java中的`long`类型），其结构如下：

![](https://bucket.shaoqunliu.cn/image/0350.png)

我们从左往右看，**第一位一直是0**，这一位是不用的，而且它也不能是1，原因很简单，这一位如果是1，那整个值都会变成负数，`id`是负数这种情况显然是不合理的。所以我们实际可用的只有后面63位。

紧接着的41个bit是时间戳，这个时间戳转换成10进制的毫秒数最大值为2199023255551。Linux的时间戳是从1970年的某个时间开始计时的毫秒数，但我们一般将其即设为从某个时间点开始的毫秒数，比如统一设置的集群启动时间，然后这41位所记录的值即为现在的时间戳减去这个统一的集群启动时间的时间戳。

然后是10bit的集群中的机器id，2的10次方是1024，也就是这个算法最多支持1024个结点，全用上这个集群的规模也可见一斑了。

最后12位是交由集群中的每个结点自行生成的自增长序列值。2的12次方即为4096，也就是说每一毫秒，每个分布式节点都可以生成4096个分布式id而不重复。

需要注意的一点是，如果前端和后端需要用到这个id来打交道的话，JavaScript最大支持的整数的精度是53位，64位已经超出了JavaScript支持的最大整数精度，**所以需要用字符串来保存这个生成的id**。这一点在[Twitter官方有关Snowflake算法的介绍文档](https://developer.twitter.com/en/docs/basics/twitter-ids)中就有提到。

这种丢失精度的现象，你可以在你浏览器的控制台使用如下代码查看：

```javascript
(90071992547409921).toString()
```

除此之外，还可以自定义精简版的Snowflake算法，比如缩小64位至53位。